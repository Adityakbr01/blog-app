import { env } from "@/config/env.js";
import { HTTP_STATUS } from "@/constants/api.constants.js";
import { Role, UserStatus } from "@/constants/user.constants.js";
import UserModel from "@/model/user.model.js";
import { AuthUser, JwtPayload } from "@/types/express.js";
import AppError from "@/utils/AppError.js";
import {
  generateAccessToken,
  generateRefreshToken,
} from "@/utils/auth.util.js";
import { LoginInput, SignupInput } from "@/validations/auth.schema.js";
import jwt from "jsonwebtoken";

// ---- Signup Service (direct registration) ----
export const signup = async (data: SignupInput) => {
  const { name, email, password } = data;

  const existingUser = await UserModel.findOne({ email });

  if (existingUser) {
    throw new AppError("User with this email already exists", HTTP_STATUS.CONFLICT);
  }

  // Create new user with ACTIVE status (password auto-hashed, username auto-generated by model)
  const user = new UserModel({
    name,
    email,
    password, // Will be auto-hashed by model pre-save hook
    role: Role.USER,
    status: UserStatus.ACTIVE,
    refreshTokens: [],
  });

  await user.save();

  // Generate tokens
  const tokenPayload: JwtPayload = {
    userId: user._id.toString(),
    email: user.email,
    role: user.role,
  };

  const accessToken = generateAccessToken(tokenPayload);
  const refreshToken = generateRefreshToken(tokenPayload);

  // Store refresh token
  user.refreshTokens.push(refreshToken);
  await user.save();

  const userData: AuthUser = {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
  };

  return {
    user: userData,
    accessToken,
    refreshToken,
    message: "Account created successfully. You are now logged in.",
  };
};

// ---- Login Service ----
export const login = async (data: LoginInput) => {
  const { email, password } = data;

  const user = await UserModel.findOne({ email });

  if (!user) {
    throw new AppError("Invalid email or password", HTTP_STATUS.UNAUTHORIZED);
  }

  // Verify password using model's comparePassword method
  const isValidPassword = await user.comparePassword(password);
  if (!isValidPassword) {
    throw new AppError("Invalid email or password", HTTP_STATUS.UNAUTHORIZED);
  }

  // Check user status
  if (user.status === UserStatus.BLOCKED) {
    throw new AppError(
      "Your account has been blocked. Please contact support.",
      HTTP_STATUS.FORBIDDEN,
    );
  }

  // Generate tokens
  const tokenPayload: JwtPayload = {
    userId: user._id.toString(),
    email: user.email,
    role: user.role,
  };

  const accessToken = generateAccessToken(tokenPayload);
  const refreshToken = generateRefreshToken(tokenPayload);

  // Store refresh token (limit to 5 sessions)
  if (user.refreshTokens.length >= 5) {
    user.refreshTokens.shift();
  }
  user.refreshTokens.push(refreshToken);
  await user.save();

  const userData: AuthUser = {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
  };

  return {
    user: userData,
    accessToken,
    refreshToken,
  };
};

// ---- Refresh Token Service ----
export const refreshToken = async (token: string) => {
  try {
    const decoded = jwt.verify(token, env.JWT_SECRET) as JwtPayload;

    if (!decoded || !decoded.userId) {
      throw new AppError("Invalid refresh token", HTTP_STATUS.UNAUTHORIZED);
    }

    // Verify user still exists and is active
    const user = await UserModel.findById(decoded.userId);

    if (!user) {
      throw new AppError("User not found", HTTP_STATUS.UNAUTHORIZED);
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new AppError("User account is not active", HTTP_STATUS.FORBIDDEN);
    }

    // Verify token is in user's refresh tokens
    if (!user.refreshTokens.includes(token)) {
      // Token reuse detected - invalidate all tokens
      user.refreshTokens = [];
      await user.save();
      throw new AppError("Invalid refresh token. Please login again.", HTTP_STATUS.UNAUTHORIZED);
    }

    // Remove old token
    user.refreshTokens = user.refreshTokens.filter((t) => t !== token);

    // Generate new tokens
    const tokenPayload: JwtPayload = {
      userId: user._id.toString(),
      email: user.email,
      role: user.role,
    };

    const accessToken = generateAccessToken(tokenPayload);
    const newRefreshToken = generateRefreshToken(tokenPayload);

    // Store new refresh token
    user.refreshTokens.push(newRefreshToken);
    await user.save();

    return {
      accessToken,
      refreshToken: newRefreshToken,
    };
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new AppError(
        "Refresh token has expired. Please login again.",
        HTTP_STATUS.UNAUTHORIZED,
      );
    }
    if (error instanceof jwt.JsonWebTokenError) {
      throw new AppError("Invalid refresh token", HTTP_STATUS.UNAUTHORIZED);
    }
    throw error;
  }
};

// ---- Logout Service ----
export const logout = async (userId: string, refreshToken?: string) => {
  const user = await UserModel.findById(userId);
  if (!user) {
    throw new AppError("User not found", HTTP_STATUS.NOT_FOUND);
  }

  if (refreshToken) {
    // Remove specific token
    user.refreshTokens = user.refreshTokens.filter((t) => t !== refreshToken);
  } else {
    // Clear all tokens (logout from all devices)
    user.refreshTokens = [];
  }
  await user.save();

  return { message: "Logged out successfully" };
};

// ---- Get User By ID ----
export const getUserById = async (userId: string): Promise<AuthUser | null> => {
  const user = await UserModel.findById(userId).select("name email role status avatar");
  if (!user) return null;

  return {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
    avatar: user.avatar,

  };
};

