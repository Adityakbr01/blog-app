import { env } from "@/config/env.js";
import { HTTP_STATUS } from "@/constants/api.constants.js";
import { Role, UserStatus } from "@/constants/user.constants.js";
import UserModel from "@/model/user.model.js";
import { AuthUser, JwtPayload } from "@/types/express.js";
import AppError from "@/utils/AppError.js";
import {
  generateAccessToken,
  generateRefreshToken,
  generateOtp,
  hashOtp,
  verifyOtp,
} from "@/utils/auth.util.js";
import { sendOtpEmail, sendPasswordResetEmail } from "@/config/mailer.js";
import { LoginInput, SignupInput, VerifyOtpInput, ResendOtpInput, ResetPasswordInput } from "@/validations/auth.schema.js";
import jwt from "jsonwebtoken";

// ---- Signup Service (sends OTP) ----
export const signup = async (data: SignupInput) => {
  const { name, email, password } = data;

  const existingUser = await UserModel.findOne({ email });

  if (existingUser && existingUser.status === UserStatus.ACTIVE) {
    throw new AppError("User with this email already exists", HTTP_STATUS.CONFLICT);
  }

  // Generate OTP (password will be auto-hashed by model pre-save hook)
  const otp = generateOtp();
  const otpHash = await hashOtp(otp);
  const otpExpiresAt = new Date(Date.now() + env.OTP_EXPIRY_MINUTES * 60 * 1000);

  if (existingUser && existingUser.status === UserStatus.PENDING) {
    // Update existing pending user
    existingUser.name = name;
    existingUser.password = password; // Will be auto-hashed by model
    existingUser.otp = {
      codeHash: otpHash,
      expiresAt: otpExpiresAt,
      lastSentAt: new Date(),
    };
    await existingUser.save();

    // Send OTP email
    await sendOtpEmail(email, otp);

    return {
      message: "OTP sent to your email. Please verify to complete registration.",
      email,
    };
  }

  // Create new user with PENDING status (password auto-hashed, username auto-generated by model)
  const user = new UserModel({
    name,
    email,
    password, // Will be auto-hashed by model pre-save hook
    role: Role.USER,
    status: UserStatus.PENDING,
    otp: {
      codeHash: otpHash,
      expiresAt: otpExpiresAt,
      lastSentAt: new Date(),
    },
    refreshTokens: [],
  });

  await user.save();

  // Send OTP email
  await sendOtpEmail(email, otp);

  return {
    message: "OTP sent to your email. Please verify to complete registration.",
    email,
  };
};

// ---- Verify OTP Service ----
export const verifyOtpAndActivate = async (data: VerifyOtpInput) => {
  const { email, otp } = data;

  const user = await UserModel.findOne({ email });

  if (!user) {
    throw new AppError("User not found", HTTP_STATUS.NOT_FOUND);
  }

  if (user.status === UserStatus.ACTIVE) {
    throw new AppError("User is already verified", HTTP_STATUS.BAD_REQUEST);
  }

  if (!user.otp || !user.otp.codeHash) {
    throw new AppError("No OTP found. Please request a new one.", HTTP_STATUS.BAD_REQUEST);
  }

  if (new Date() > user.otp.expiresAt) {
    throw new AppError("OTP has expired. Please request a new one.", HTTP_STATUS.BAD_REQUEST);
  }

  const isValidOtp = await verifyOtp(otp, user.otp.codeHash);

  if (!isValidOtp) {
    throw new AppError("Invalid OTP", HTTP_STATUS.BAD_REQUEST);
  }

  // Activate user and clear OTP
  user.status = UserStatus.ACTIVE;
  user.otp = null;
  await user.save();

  // Generate tokens
  const tokenPayload: JwtPayload = {
    userId: user._id.toString(),
    email: user.email,
    role: user.role,
  };

  const accessToken = generateAccessToken(tokenPayload);
  const refreshToken = generateRefreshToken(tokenPayload);

  // Store refresh token
  user.refreshTokens.push(refreshToken);
  await user.save();

  const userData: AuthUser = {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
  };

  return {
    user: userData,
    accessToken,
    refreshToken,
    message: "Email verified successfully. You are now logged in.",
  };
};

// ---- Resend OTP Service ----
export const resendOtp = async (data: ResendOtpInput) => {
  const { email, type } = data;
  const user = await UserModel.findOne({ email });

  if (!user) {
    throw new AppError("User not found", HTTP_STATUS.NOT_FOUND);
  }

  // For signup OTP, user must be PENDING
  if (type === "signup" && user.status === UserStatus.ACTIVE) {
    throw new AppError("User is already verified", HTTP_STATUS.BAD_REQUEST);
  }

  // For forgot password OTP, user must be ACTIVE
  if (type === "forgot-password" && user.status !== UserStatus.ACTIVE) {
    throw new AppError("Account is not active. Please verify your email first.", HTTP_STATUS.BAD_REQUEST);
  }

  // Rate limiting: prevent spamming
  if (user.otp?.lastSentAt) {
    const timeSinceLastSent = Date.now() - user.otp.lastSentAt.getTime();
    if (timeSinceLastSent < 60000) {
      const waitSeconds = Math.ceil((60000 - timeSinceLastSent) / 1000);
      throw new AppError(`Please wait ${waitSeconds} seconds before requesting a new OTP`, HTTP_STATUS.TOO_MANY_REQUESTS);
    }
  }

  const otp = generateOtp();
  const otpHash = await hashOtp(otp);

  user.otp = {
    codeHash: otpHash,
    expiresAt: new Date(Date.now() + env.OTP_EXPIRY_MINUTES * 60 * 1000),
    lastSentAt: new Date(),
  };
  await user.save();

  // Send appropriate email based on type
  if (type === "forgot-password") {
    await sendPasswordResetEmail(email, otp);
  } else {
    await sendOtpEmail(email, otp);
  }

  return {
    message: "OTP sent to your email.",
    email,
  };
};

// ---- Forgot Password Service ----
export const forgotPassword = async (email: string) => {
  const user = await UserModel.findOne({ email });

  if (!user) {
    // Don't reveal if user exists or not for security
    return {
      message: "If an account with this email exists, you will receive a password reset OTP.",
      email,
    };
  }

  if (user.status !== UserStatus.ACTIVE) {
    throw new AppError("Account is not active. Please verify your email first.", HTTP_STATUS.BAD_REQUEST);
  }

  // Rate limiting
  if (user.otp?.lastSentAt) {
    const timeSinceLastSent = Date.now() - user.otp.lastSentAt.getTime();
    if (timeSinceLastSent < 60000) {
      const waitSeconds = Math.ceil((60000 - timeSinceLastSent) / 1000);
      throw new AppError(`Please wait ${waitSeconds} seconds before requesting a new OTP`, HTTP_STATUS.TOO_MANY_REQUESTS);
    }
  }

  const otp = generateOtp();
  const otpHash = await hashOtp(otp);

  user.otp = {
    codeHash: otpHash,
    expiresAt: new Date(Date.now() + env.OTP_EXPIRY_MINUTES * 60 * 1000),
    lastSentAt: new Date(),
  };
  await user.save();

  await sendPasswordResetEmail(email, otp);

  return {
    message: "If an account with this email exists, you will receive a password reset OTP.",
    email,
  };
};

// ---- Reset Password Service ----
export const resetPassword = async (data: ResetPasswordInput) => {
  const { email, otp, newPassword } = data;

  const user = await UserModel.findOne({ email });

  if (!user) {
    throw new AppError("Invalid request", HTTP_STATUS.BAD_REQUEST);
  }

  if (user.status !== UserStatus.ACTIVE) {
    throw new AppError("Account is not active", HTTP_STATUS.BAD_REQUEST);
  }

  if (!user.otp || !user.otp.codeHash) {
    throw new AppError("No password reset request found. Please request a new one.", HTTP_STATUS.BAD_REQUEST);
  }

  if (new Date() > user.otp.expiresAt) {
    throw new AppError("OTP has expired. Please request a new one.", HTTP_STATUS.BAD_REQUEST);
  }

  const isValidOtp = await verifyOtp(otp, user.otp.codeHash);

  if (!isValidOtp) {
    throw new AppError("Invalid OTP", HTTP_STATUS.BAD_REQUEST);
  }

  // Update password and clear OTP (password will be auto-hashed by model)
  user.password = newPassword;
  user.otp = null;
  // Clear all refresh tokens for security
  user.refreshTokens = [];
  await user.save();

  return {
    message: "Password reset successfully. Please login with your new password.",
  };
};

// ---- Login Service ----
export const login = async (data: LoginInput) => {
  const { email, password } = data;

  const user = await UserModel.findOne({ email });

  if (!user) {
    throw new AppError("Invalid email or password", HTTP_STATUS.UNAUTHORIZED);
  }

  // Verify password using model's comparePassword method
  const isValidPassword = await user.comparePassword(password);
  if (!isValidPassword) {
    throw new AppError("Invalid email or password", HTTP_STATUS.UNAUTHORIZED);
  }

  // Check user status
  if (user.status === UserStatus.PENDING) {
    throw new AppError(
      "Your email is not verified. Please verify your email first.",
      HTTP_STATUS.FORBIDDEN,
    );
  }

  if (user.status === UserStatus.BLOCKED) {
    throw new AppError(
      "Your account has been blocked. Please contact support.",
      HTTP_STATUS.FORBIDDEN,
    );
  }

  // Generate tokens
  const tokenPayload: JwtPayload = {
    userId: user._id.toString(),
    email: user.email,
    role: user.role,
  };

  const accessToken = generateAccessToken(tokenPayload);
  const refreshToken = generateRefreshToken(tokenPayload);

  // Store refresh token (limit to 5 sessions)
  if (user.refreshTokens.length >= 5) {
    user.refreshTokens.shift();
  }
  user.refreshTokens.push(refreshToken);
  await user.save();

  const userData: AuthUser = {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
  };

  return {
    user: userData,
    accessToken,
    refreshToken,
  };
};

// ---- Refresh Token Service ----
export const refreshToken = async (token: string) => {
  try {
    const decoded = jwt.verify(token, env.JWT_SECRET) as JwtPayload;

    if (!decoded || !decoded.userId) {
      throw new AppError("Invalid refresh token", HTTP_STATUS.UNAUTHORIZED);
    }

    // Verify user still exists and is active
    const user = await UserModel.findById(decoded.userId);

    if (!user) {
      throw new AppError("User not found", HTTP_STATUS.UNAUTHORIZED);
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new AppError("User account is not active", HTTP_STATUS.FORBIDDEN);
    }

    // Verify token is in user's refresh tokens
    if (!user.refreshTokens.includes(token)) {
      // Token reuse detected - invalidate all tokens
      user.refreshTokens = [];
      await user.save();
      throw new AppError("Invalid refresh token. Please login again.", HTTP_STATUS.UNAUTHORIZED);
    }

    // Remove old token
    user.refreshTokens = user.refreshTokens.filter((t) => t !== token);

    // Generate new tokens
    const tokenPayload: JwtPayload = {
      userId: user._id.toString(),
      email: user.email,
      role: user.role,
    };

    const accessToken = generateAccessToken(tokenPayload);
    const newRefreshToken = generateRefreshToken(tokenPayload);

    // Store new refresh token
    user.refreshTokens.push(newRefreshToken);
    await user.save();

    return {
      accessToken,
      refreshToken: newRefreshToken,
    };
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new AppError(
        "Refresh token has expired. Please login again.",
        HTTP_STATUS.UNAUTHORIZED,
      );
    }
    if (error instanceof jwt.JsonWebTokenError) {
      throw new AppError("Invalid refresh token", HTTP_STATUS.UNAUTHORIZED);
    }
    throw error;
  }
};

// ---- Logout Service ----
export const logout = async (userId: string, refreshToken?: string) => {
  const user = await UserModel.findById(userId);
  if (!user) {
    throw new AppError("User not found", HTTP_STATUS.NOT_FOUND);
  }

  if (refreshToken) {
    // Remove specific token
    user.refreshTokens = user.refreshTokens.filter((t) => t !== refreshToken);
  } else {
    // Clear all tokens (logout from all devices)
    user.refreshTokens = [];
  }
  await user.save();

  return { message: "Logged out successfully" };
};

// ---- Get User By ID ----
export const getUserById = async (userId: string): Promise<AuthUser | null> => {
  const user = await UserModel.findById(userId).select("name email role status avatar");
  if (!user) return null;

  return {
    id: user._id.toString(),
    name: user.name,
    email: user.email,
    role: user.role,
    status: user.status,
    avatar: user.avatar,

  };
};

